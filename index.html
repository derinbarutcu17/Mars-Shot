<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Mars Shot: Orbital Injection</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none; /* Critical for mobile to prevent scrolling */
            user-select: none;
            -webkit-user-select: none;
        }
        #gameCanvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 20px;
            pointer-events: none;
            z-index: 5;
            text-shadow: 1px 1px 2px black;
            width: 100%;
            box-sizing: border-box;
            padding-right: 20px;
        }
        /* Top Center Level Selector */
        #levelSelectContainer {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: auto;
            z-index: 6;
        }
        #levelSelect {
            background-color: #9d00ff;
            color: white;
            border: 2px solid #fff;
            padding: 8px 15px;
            font-family: inherit;
            font-weight: bold;
            font-size: 16px;
            border-radius: 20px;
            cursor: pointer;
            outline: none;
            text-align: center;
        }
        
        /* Typography Scaling */
        h1 { margin: 0; font-size: 24px; text-shadow: 0 0 10px #00d2ff; }
        p { margin: 2px 0; font-size: 14px; color: #ccc; }
        
        #fuelBarContainer {
            margin-top: 5px;
            width: 120px;
            height: 8px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid #fff;
            border-radius: 5px;
            overflow: hidden;
            display: none; 
        }
        #fuelBar { width: 100%; height: 100%; background: #ffaa00; transition: width 0.1s; }
        #coinText { color: #ffd700; font-weight: bold; }
        
        /* Buttons - Mobile Optimized */
        .btn {
            pointer-events: auto;
            background: linear-gradient(180deg, #00d2ff 0%, #0078ff 100%);
            color: #fff;
            border: none;
            padding: 15px 30px; /* Larger touch target */
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            border-radius: 8px;
            text-transform: uppercase;
            box-shadow: 0 4px 0 #0056b3;
        }
        .btn:active { transform: translateY(4px); box-shadow: none; }
        .green-btn { background: linear-gradient(180deg, #44ff44 0%, #00aa00 100%); box-shadow: 0 4px 0 #006600; }
        
        /* Store Modal */
        #storeModal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 20, 0.98);
            border: 2px solid #ffd700;
            padding: 20px;
            border-radius: 10px;
            display: none;
            z-index: 20;
            width: 85%;
            max-width: 350px;
            text-align: center;
        }
        .upgrade-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 15px 0;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }
        .buy-btn {
            background: #333; color: #fff; border: 1px solid #555;
            padding: 10px 15px; cursor: pointer; font-size: 14px; border-radius: 4px;
        }

        /* Message Modal */
        #message {
            position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; pointer-events: none; display: none; z-index: 10;
            background: rgba(12, 12, 20, 0.95); padding: 30px;
            border: 2px solid #00d2ff; border-radius: 8px;
            min-width: 300px; width: 80%;
        }

        /* In-Game Buttons */
        #resetLevelBtn, #storeToggleBtn {
            position: absolute;
            padding: 12px 16px;
            font-family: inherit; font-weight: bold; font-size: 14px;
            cursor: pointer; pointer-events: auto; z-index: 5;
            border-radius: 6px;
        }
        #resetLevelBtn {
            bottom: 20px; left: 20px;
            background: rgba(255, 50, 50, 0.2); border: 1px solid #ff4444; color: #ffaaaa;
        }
        #storeToggleBtn {
            top: 10px; right: 20px;
            background: rgba(255, 215, 0, 0.2); border: 1px solid #ffd700; color: #ffd700;
        }

        /* Mobile specific adjustments */
        @media (max-width: 600px) {
            h1 { font-size: 20px; }
            #levelSelectContainer { top: 75px; } /* Move below coins on mobile */
            #ui { top: 5px; left: 10px; }
        }
    </style>
</head>
<body>

<div id="levelSelectContainer">
    <select id="levelSelect" onchange="changeLevel(this.value)">
        <option value="1">Level 1</option>
        <option value="2">Level 2</option>
        <option value="3">Level 3</option>
        <option value="4">Level 4</option>
    </select>
</div>

<div id="ui">
    <h1>MARS SHOT</h1>
    <p>Coins: <span id="coinText">0</span></p>
    <p><span id="statusText">Ready</span></p>
    <p>Closest: <span id="distanceText">--</span></p>
    <div id="fuelBarContainer">
        <div id="fuelBar"></div>
    </div>
</div>

<button id="resetLevelBtn">â†º RESET</button>
<button id="storeToggleBtn">SHOP</button>

<!-- Store Modal -->
<div id="storeModal">
    <h2 style="color:#ffd700; margin-top:0;">WORKSHOP</h2>
    <div id="upgradesList"></div>
    <button class="btn" onclick="closeStore()">Close</button>
</div>

<!-- End Game Modal -->
<div id="message">
    <h2 id="msgTitle">MISSION COMPLETE</h2>
    <p id="msgSub">Score: 100</p>
    <br>
    <button class="btn" id="retryBtn">Try Again</button>
    <button class="btn green-btn" id="nextLevelBtn" style="display:none; margin-left:10px;">Next Level</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
(function() {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elements
    const statusText = document.getElementById('statusText');
    const distanceText = document.getElementById('distanceText');
    const levelSelect = document.getElementById('levelSelect');
    const coinText = document.getElementById('coinText');
    const fuelBarContainer = document.getElementById('fuelBarContainer');
    const fuelBar = document.getElementById('fuelBar');
    const messageOverlay = document.getElementById('message');
    const msgTitle = document.getElementById('msgTitle');
    const msgSub = document.getElementById('msgSub');
    const retryBtn = document.getElementById('retryBtn');
    const nextLevelBtn = document.getElementById('nextLevelBtn');
    const resetLevelBtn = document.getElementById('resetLevelBtn');
    const storeModal = document.getElementById('storeModal');
    const storeToggleBtn = document.getElementById('storeToggleBtn');
    const upgradesList = document.getElementById('upgradesList');

    let width, height, cx, cy;
    let scaleFactor = 1; // Master scale for mobile adjustment
    let animationFrameId;

    // --- PHYSICS CONSTANTS (Base values, scaled later) ---
    let G_BASE = 0.35;
    const SUN_MASS = 5000;
    const EARTH_MASS = 100;
    const MARS_MASS = 80;
    const SATURN_MASS = 200;
    const MOON_MASS = 10;
    
    let MAX_INPUT_DIST = 300; 

    // Stats & Upgrades
    let coins = 0;
    let upgrades = {
        fuel: { level: 1, cost: 50, name: "Fuel Tank", max: 5 },
        thrust: { level: 1, cost: 80, name: "Ion Engine", max: 5 },
        launch: { level: 1, cost: 60, name: "Catapult", max: 5 }
    };

    function getStats() {
        return {
            maxFuel: 100 + (upgrades.fuel.level - 1) * 30,
            thrustPower: (0.1 + (upgrades.thrust.level - 1) * 0.025) * scaleFactor, // Scale thrust
            launchForceMin: 1.5 * scaleFactor, // Scale launch
            launchForceMax: (5.0 + (upgrades.launch.level - 1) * 1.0) * scaleFactor
        };
    }

    // Game State
    let bodies = [];
    let rocket = null;
    let ghostTrail = [];
    let particles = [];
    let gameState = 'IDLE';
    let closestDist = Infinity;
    let level = 1;
    let stars = [];
    let shakeStrength = 0;
    let isThrusting = false;

    let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };

    class Vector {
        constructor(x, y) { this.x = x; this.y = y; }
        add(v) { if(v) { this.x += v.x; this.y += v.y; } }
        sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
        mult(n) { this.x *= n; this.y *= n; }
        mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
        normalize() { 
            let m = this.mag(); 
            if(m !== 0 && Number.isFinite(m)) { this.x /= m; this.y /= m; }
        }
        copy() { return new Vector(this.x, this.y); }
        heading() { return Math.atan2(this.y, this.x); }
    }

    class Body {
        constructor(x, y, mass, radius, color, isStatic = false, type = 'planet') {
            this.pos = new Vector(x, y);
            this.vel = new Vector(0, 0);
            this.acc = new Vector(0, 0);
            this.mass = mass;
            this.radius = radius * scaleFactor; // Visual size scaled
            this.color = color;
            this.isStatic = isStatic;
            this.type = type;
            this.trail = [];
            
            this.orbitCenter = null;
            this.parentBody = null;
            this.orbitRadius = 0;
            this.orbitAngle = Math.random() * Math.PI * 2;
            this.orbitSpeed = 0;

            this.startPos = new Vector(x, y);
            this.oscillate = false;
            this.oscillateSpeed = 0.0;
            this.oscillateDist = 0;
            this.timeOffset = 0;

            this.fuel = 0;
            this.angle = 0;
            this.age = 0;

            this.shapeVertices = [];
            if (this.type === 'obstacle') {
                let numPoints = 6 + Math.floor(Math.random() * 4);
                for (let i = 0; i < numPoints; i++) {
                    let angle = (i / numPoints) * Math.PI * 2;
                    let r = this.radius * (0.7 + Math.random() * 0.6);
                    this.shapeVertices.push({
                        x: Math.cos(angle) * r,
                        y: Math.sin(angle) * r
                    });
                }
            }
        }

        applyForce(f) {
            let fCopy = f.copy();
            fCopy.mult(1 / this.mass);
            this.acc.add(fCopy);
        }

        update() {
            if (this.orbitCenter) {
                this.orbitAngle += this.orbitSpeed;
                this.pos.x = this.orbitCenter.x + Math.cos(this.orbitAngle) * this.orbitRadius;
                this.pos.y = this.orbitCenter.y + Math.sin(this.orbitAngle) * this.orbitRadius;
                this.vel.x = -Math.sin(this.orbitAngle) * this.orbitRadius * this.orbitSpeed;
                this.vel.y = Math.cos(this.orbitAngle) * this.orbitRadius * this.orbitSpeed;
            } else if (this.parentBody) {
                this.orbitAngle += this.orbitSpeed;
                this.pos.x = this.parentBody.pos.x + Math.cos(this.orbitAngle) * this.orbitRadius;
                this.pos.y = this.parentBody.pos.y + Math.sin(this.orbitAngle) * this.orbitRadius;
                this.vel.x = this.parentBody.vel.x - Math.sin(this.orbitAngle) * this.orbitRadius * this.orbitSpeed;
                this.vel.y = this.parentBody.vel.y + Math.cos(this.orbitAngle) * this.orbitRadius * this.orbitSpeed;
            } else if (this.oscillate) {
                this.pos.y = this.startPos.y + Math.sin((frameCount * this.oscillateSpeed) + this.timeOffset) * this.oscillateDist;
            } else if (!this.isStatic) {
                this.vel.add(this.acc);
                this.pos.add(this.vel);
            }
            
            this.acc.mult(0); 
            
            if (this.type === 'rocket') {
                this.age++;
                if (isThrusting) {
                    let target = new Vector(mouse.x, mouse.y);
                    let dir = target.sub(this.pos);
                    this.angle = dir.heading();
                } else if(this.vel.mag() > 0.1) {
                    this.angle = this.vel.heading();
                }
            }

            if (this.type === 'planet' || this.type === 'rocket') {
                if (frameCount % 5 === 0) {
                    this.trail.push({x: this.pos.x, y: this.pos.y});
                    let limit = this.type === 'rocket' ? 600 : 60;
                    if (this.trail.length > limit) this.trail.shift();
                }
            }
        }

        draw() {
            if (!Number.isFinite(this.pos.x) || !Number.isFinite(this.pos.y)) return;

            // Dashed Orbit Lines
            if ((this.orbitCenter || (this.parentBody && this.type === 'moon')) && this.type !== 'obstacle') {
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 10]);
                if (this.orbitCenter) {
                    ctx.arc(this.orbitCenter.x, this.orbitCenter.y, this.orbitRadius, 0, Math.PI * 2);
                } else if (this.parentBody) {
                    ctx.arc(this.parentBody.pos.x, this.parentBody.pos.y, this.orbitRadius, 0, Math.PI * 2);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Trail
            if (this.trail.length > 1) {
                ctx.beginPath();
                ctx.strokeStyle = this.type === 'rocket' ? '#fff' : this.color;
                ctx.lineWidth = this.type === 'rocket' ? 1.5 : 1;
                ctx.globalAlpha = 0.3;
                for (let i = 0; i < this.trail.length - 1; i++) {
                    ctx.lineTo(this.trail[i].x, this.trail[i].y);
                }
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            }

            // Draw Rocket
            if (this.type === 'rocket') {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(this.angle);
                
                // Scale drawing context for rocket size
                ctx.scale(scaleFactor, scaleFactor);

                if (isThrusting && this.fuel > 0) {
                    ctx.beginPath();
                    ctx.moveTo(-10, -2);
                    ctx.lineTo(-20 - Math.random() * 8, 0);
                    ctx.lineTo(-10, 2);
                    ctx.fillStyle = '#ffaa00';
                    ctx.fill();
                }

                ctx.beginPath();
                ctx.ellipse(0, 0, 10, 4, 0, 0, Math.PI*2);
                ctx.fillStyle = '#eee';
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(-4, -4);
                ctx.lineTo(-12, -8);
                ctx.lineTo(-8, 0);
                ctx.lineTo(-12, 8);
                ctx.lineTo(-4, 4);
                ctx.fillStyle = '#cc3333';
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(3, 0, 3, 2, 0, 0, Math.PI*2);
                ctx.fillStyle = '#00d2ff';
                ctx.fill();
                
                ctx.restore();
                return;
            }

            // Asteroids
            if (this.type === 'obstacle' && this.shapeVertices.length > 0) {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(this.orbitAngle * 2); 
                ctx.beginPath();
                ctx.moveTo(this.shapeVertices[0].x, this.shapeVertices[0].y);
                for (let i = 1; i < this.shapeVertices.length; i++) {
                    ctx.lineTo(this.shapeVertices[i].x, this.shapeVertices[i].y);
                }
                ctx.closePath();
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.stroke();
                ctx.restore();
                return;
            }

            // Planets
            if (this.type === 'sun' || this.type === 'target_start' || this.type === 'target_end' || this.type === 'saturn') {
                let glowSize = this.radius * 2;
                let g = ctx.createRadialGradient(this.pos.x, this.pos.y, this.radius, this.pos.x, this.pos.y, glowSize);
                g.addColorStop(0, this.color);
                g.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, glowSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }

            let grad = ctx.createRadialGradient(
                this.pos.x - this.radius*0.3, this.pos.y - this.radius*0.3, this.radius * 0.1,
                this.pos.x, this.pos.y, this.radius
            );

            if (this.type === 'sun') {
                grad.addColorStop(0, '#fff');
                grad.addColorStop(1, '#ff8800');
                ctx.shadowBlur = 40;
                ctx.shadowColor = '#ff8800';
            } else if (this.type === 'target_start') {
                grad.addColorStop(0, '#88ccff');
                grad.addColorStop(1, '#0055aa');
                ctx.shadowBlur = 0;
            } else if (this.type === 'target_end') {
                grad.addColorStop(0, '#ff8888');
                grad.addColorStop(1, '#aa2222');
                ctx.shadowBlur = 0;
            } else if (this.type === 'saturn') {
                grad.addColorStop(0, '#f4d03f');
                grad.addColorStop(1, '#b7950b');
                ctx.shadowBlur = 0;
            } else if (this.type === 'moon') {
                grad.addColorStop(0, '#ddd');
                grad.addColorStop(1, '#888');
                ctx.shadowBlur = 0;
            } else {
                grad.addColorStop(0, '#aaa');
                grad.addColorStop(1, '#555');
                ctx.shadowBlur = 0;
            }

            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.pos = new Vector(x, y);
            this.vel = new Vector((Math.random() - 0.5) * 4 * scaleFactor, (Math.random() - 0.5) * 4 * scaleFactor);
            this.life = 1.0;
            this.color = color;
            this.size = (Math.random() * 3 + 1) * scaleFactor;
        }
        update() {
            this.pos.add(this.vel);
            this.life -= 0.03;
        }
        draw() {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        cx = width / 2;
        cy = height / 2;
        
        // --- ADAPTIVE SCALING ---
        // Base reference: 1000px wide
        scaleFactor = Math.min(width, height) / 800; 
        if (scaleFactor > 1.2) scaleFactor = 1.2; // Cap max size
        if (scaleFactor < 0.6) scaleFactor = 0.6; // Cap min size (keep things visible)

        // Adjust gravity constant based on scale to keep orbits stable visually
        // G must allow orbit speed to match the pixels
        // G = v^2 * r / M
        // If we scale r by S, we want v to scale by S (to look same speed).
        // Then v^2 * r scales by S^3.
        // So G must scale by S^3 if Mass is constant?
        // Simpler: Just scale G linearly with radius scale usually works fine for 2D visual feel
        // But actually, simpler is to just adjust G slightly down for small screens.
        
        MAX_INPUT_DIST = 300 * scaleFactor;

        mouse.x = cx;
        mouse.y = cy;
        initStars();
        if (gameState === 'IDLE') resetGame('stay');
    }

    function initStars() {
        stars = [];
        for(let i=0; i<150; i++) {
            stars.push({
                x: Math.random() * width,
                y: Math.random() * height,
                size: Math.random() * 1.5,
                alpha: Math.random() * 0.8 + 0.2
            });
        }
    }

    function createSolarSystem() {
        bodies = [];
        
        // Scale Factor for distances
        // On mobile (w=400), r1 should be smaller than on PC (w=1920)
        // But we want it relative to screen size.
        
        let sun = new Body(cx, cy, SUN_MASS, 30, '#ffd700', true, 'sun');
        bodies.push(sun);

        let r1 = Math.min(width, height) * 0.22;
        let earth = new Body(cx + r1, cy, EARTH_MASS, 10, '#4facfe', false, 'target_start');
        earth.orbitCenter = new Vector(cx, cy);
        earth.orbitRadius = r1;
        earth.orbitAngle = 0; 
        // Orbit speed formula: v = sqrt(GM/r). Since we changed r, v changes naturally? 
        // We need to scale G accordingly or just trust the visual hack.
        // Let's use a calibrated G for the scale.
        let localG = G_BASE * scaleFactor; 
        
        earth.orbitSpeed = 0.005; 
        bodies.push(earth);

        let moonDist = 25 * scaleFactor;
        let moon = new Body(cx + r1 + moonDist, cy, MOON_MASS, 3, '#ccc', false, 'moon');
        moon.parentBody = earth;
        moon.orbitRadius = moonDist;
        moon.orbitSpeed = 0.08; 
        bodies.push(moon);

        let r2 = Math.min(width, height) * 0.35;
        let startAngle = Math.PI; // Opposite
        
        let mars = new Body(cx, cy, MARS_MASS, 9, '#ff5e62', false, 'target_end');
        mars.orbitCenter = new Vector(cx, cy);
        mars.orbitRadius = r2;
        mars.orbitAngle = startAngle;
        mars.orbitSpeed = 0.003;
        bodies.push(mars);

        let rSaturn = Math.min(width, height) * 0.48; 
        let saturn = new Body(cx, cy, SATURN_MASS, 18, '#f4d03f', false, 'saturn');
        saturn.orbitCenter = new Vector(cx, cy);
        saturn.orbitRadius = rSaturn;
        saturn.orbitAngle = Math.PI / 2;
        saturn.orbitSpeed = 0.001;
        bodies.push(saturn);

        let ringCount = 12;
        for (let i = 0; i < ringCount; i++) {
            let ringRock = new Body(0, 0, 5, 2, '#8d6e63', false, 'obstacle'); 
            ringRock.parentBody = saturn;
            ringRock.orbitRadius = (30 * scaleFactor) + Math.random() * (10 * scaleFactor);
            ringRock.orbitAngle = (i / ringCount) * Math.PI * 2;
            ringRock.orbitSpeed = 0.05 + Math.random() * 0.02;
            bodies.push(ringRock);
        }

        let asteroidCount = 0;
        let minSize = 5 * scaleFactor;
        let maxSize = 10 * scaleFactor;
        let orbitZoneStart = r1 + (30 * scaleFactor); 
        let orbitZoneEnd = r2 - (30 * scaleFactor);

        if (level === 1) {
            asteroidCount = 3;
            minSize = 6 * scaleFactor; maxSize = 10 * scaleFactor;
        } else if (level === 2) {
            asteroidCount = 8;
            minSize = 8 * scaleFactor; maxSize = 14 * scaleFactor;
        } else if (level === 3) {
            asteroidCount = 14;
            minSize = 10 * scaleFactor; maxSize = 18 * scaleFactor;
        } else if (level === 4) {
            asteroidCount = 20;
            minSize = 8 * scaleFactor; maxSize = 22 * scaleFactor;
            orbitZoneEnd = rSaturn - (30 * scaleFactor); 
        }

        for (let i = 0; i < asteroidCount; i++) {
            let size = minSize + Math.random() * (maxSize - minSize);
            let asteroid = new Body(0, 0, 20, size, '#777', false, 'obstacle');
            
            asteroid.orbitCenter = new Vector(cx, cy);
            asteroid.orbitRadius = orbitZoneStart + Math.random() * (orbitZoneEnd - orbitZoneStart);
            asteroid.orbitAngle = Math.random() * Math.PI * 2;
            let speed = 0.002 + Math.random() * 0.004;
            if (Math.random() > 0.5) speed *= -1; 
            asteroid.orbitSpeed = speed;
            
            bodies.push(asteroid);
        }
    }

    window.changeLevel = function(val) {
        level = parseInt(val);
        resetGame('stay');
    }

    function resetGame(action) {
        if (action === 'reset') {
            level = 1;
            ghostTrail = [];
        } else if (action === 'next') {
            level++;
            ghostTrail = [];
            if (level > 4) level = 1;
        }
        
        levelSelect.value = level;
        coinText.innerText = coins;
        
        gameState = 'IDLE';
        messageOverlay.style.display = 'none';
        nextLevelBtn.style.display = 'none';
        storeModal.style.display = 'none';
        
        rocket = null;
        closestDist = Infinity;
        distanceText.innerText = "--";
        fuelBarContainer.style.display = 'none';
        
        createSolarSystem();
        statusText.innerText = "Aim & Drag to Launch";
        statusText.style.color = "#fff";
    }

    function spawnExplosion(x, y, color) {
        shakeStrength = 10;
        for(let i=0; i<30; i++) {
            particles.push(new Particle(x, y, color));
        }
    }

    function calculateGravity() {
        if (!rocket) return;
        
        const stats = getStats();
        let localG = G_BASE * scaleFactor; // Scale gravity strength

        // Thrust
        if (isThrusting && rocket.fuel > 0) {
            let target = new Vector(mouse.x, mouse.y);
            let force = target.sub(rocket.pos); 
            force.normalize();
            force.mult(stats.thrustPower); 
            rocket.applyForce(force);
            rocket.fuel -= 0.5; 
            if(rocket.fuel < 0) rocket.fuel = 0;
            
            if (frameCount % 3 === 0) {
                    let exhaust = force.copy();
                    exhaust.mult(-5); 
                    particles.push(new Particle(rocket.pos.x, rocket.pos.y, '#ffaa00'));
            }
        }
        
        let fuelPct = (rocket.fuel / stats.maxFuel) * 100;
        fuelBar.style.width = `${fuelPct}%`;

        // Gravity
        for (let b of bodies) {
            if (b.type === 'rocket') continue; 
            
            let force = b.pos.sub(rocket.pos);
            let dist = force.mag();
            force.normalize();
            
            // Gravity Formula adjusted for scale
            // F = G * m1 * m2 / r^2
            // To prevent massive forces when close, we clamp distance
            let distClamped = Math.max(dist, 10 * scaleFactor);
            
            let strength = (localG * b.mass * 1) / (distClamped * distClamped); 
            
            // Artificial boost for sun gravity at distance to keep game playable
            if (b.type === 'sun') strength *= 1.5; 

            force.mult(strength);
            rocket.applyForce(force);

            // Collision
            // Scale collision radius
            let collisionDist = b.radius + (4 * scaleFactor);
            if (dist < collisionDist) { 
                let rx = rocket.pos.x;
                let ry = rocket.pos.y;

                if (b.type === 'target_end') {
                    endGame(true, 'landed');
                } else if (b.type === 'target_start') {
                        if (rocket.age > 100) {
                            endGame(false, 'crashed');
                        } else { continue; }
                } else {
                    endGame(false, 'crashed');
                }
                
                spawnExplosion(rx, ry, b.color);
                rocket = null; 
                return; 
            }
        }

        let mars = bodies.find(b => b.type === 'target_end');
        if (mars && rocket) {
             let d = rocket.pos.sub(mars.pos).mag();
             if (d < closestDist) {
                closestDist = d;
                distanceText.innerText = Math.floor(closestDist);
             }
        }
    }

    function endGame(success, reason) {
        gameState = 'ENDED';
        isThrusting = false;
        fuelBarContainer.style.display = 'none';
        
        let endRocketTrail = rocket ? [...rocket.trail] : [];
        rocket = null;
        if (endRocketTrail.length > 0) ghostTrail = endRocketTrail;

        if (success) {
            let earned = 100;
            coins += earned;
            msgTitle.innerText = "MARS LANDING!";
            msgTitle.style.color = "#44ff44";
            msgSub.innerText = `+${earned} Coins!`;
            retryBtn.innerText = "Replay Level";
            nextLevelBtn.style.display = "inline-block";
        } else {
            let distScore = Math.max(0, 50 - Math.floor(closestDist / 2));
            if (reason === 'crashed') distScore = 0;
            coins += distScore;

            if (reason === 'lost_space') {
                msgTitle.innerText = "LOST IN SPACE";
                msgTitle.style.color = "#ffaa00";
            } else {
                msgTitle.innerText = "CRASHED";
                msgTitle.style.color = "#ff4444";
            }
            msgSub.innerText = `Closest: ${Math.floor(closestDist)} | Earned: ${distScore} Coins`;
            retryBtn.innerText = "Try Again";
            nextLevelBtn.style.display = "none";
        }

        coinText.innerText = coins;
        messageOverlay.style.display = 'block';
    }

    function getLaunchVector() {
        let earth = bodies.find(b => b.type === 'target_start');
        if(!earth) return { vec: new Vector(0,0), power: 0 };
        
        const stats = getStats();

        let target = new Vector(mouse.x, mouse.y);
        let dir = target.sub(earth.pos);
        let dist = dir.mag();
        dir.normalize();

        let powerRatio = Math.min(dist, MAX_INPUT_DIST) / MAX_INPUT_DIST;
        let force = stats.launchForceMin + (stats.launchForceMax - stats.launchForceMin) * powerRatio;

        let launchVel = dir.copy();
        launchVel.mult(force);
        
        if(earth.vel) launchVel.add(earth.vel);
        
        return { vec: launchVel, power: powerRatio };
    }

    // --- STORE LOGIC ---
    window.openStore = () => {
        storeModal.style.display = 'block';
        renderStore();
    };
    window.closeStore = () => {
        storeModal.style.display = 'none';
    };
    window.buyUpgrade = (type) => {
        let u = upgrades[type];
        if (u.level < u.max && coins >= u.cost) {
            coins -= u.cost;
            u.level++;
            u.cost = Math.floor(u.cost * 1.5);
            coinText.innerText = coins;
            renderStore();
        }
    };

    function renderStore() {
        upgradesList.innerHTML = '';
        for (let key in upgrades) {
            let u = upgrades[key];
            let row = document.createElement('div');
            row.className = 'upgrade-row';
            
            let btnText = u.level >= u.max ? "MAX" : `Buy (${u.cost}c)`;
            let disabled = (u.level >= u.max || coins < u.cost) ? "opacity:0.5; pointer-events:none;" : "";
            
            row.innerHTML = `
                <div class="upgrade-info">
                    <span class="upgrade-name">${u.name} (Lvl ${u.level})</span>
                </div>
                <button class="buy-btn" style="${disabled}" onclick="buyUpgrade('${key}')">${btnText}</button>
            `;
            upgradesList.appendChild(row);
        }
    }

    let frameCount = 0;
    function loop() {
        let shakeX = 0, shakeY = 0;
        if(shakeStrength > 0) {
            shakeX = (Math.random() - 0.5) * shakeStrength;
            shakeY = (Math.random() - 0.5) * shakeStrength;
            shakeStrength *= 0.9;
            if(shakeStrength < 0.5) shakeStrength = 0;
        }

        ctx.save();
        ctx.translate(shakeX, shakeY);
        ctx.fillStyle = '#050510';
        ctx.fillRect(-shakeX, -shakeY, width, height);

        for(let s of stars) {
            if(Math.random() < 0.01) s.alpha = Math.random() * 0.8 + 0.2;
            ctx.fillStyle = `rgba(255, 255, 255, ${s.alpha})`;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
            ctx.fill();
        }

        calculateGravity();

        for (let b of bodies) {
            b.update();
            b.draw();
        }

        if (ghostTrail.length > 1) {
            ctx.beginPath();
            ctx.strokeStyle = '#00ffff'; 
            ctx.lineWidth = 1 * scaleFactor;
            ctx.globalAlpha = 0.2; 
            ctx.setLineDash([5, 5]);
            for (let i = 0; i < ghostTrail.length - 1; i++) {
                ctx.lineTo(ghostTrail[i].x, ghostTrail[i].y);
            }
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.globalAlpha = 1.0;
        }

        if (gameState === 'IDLE') {
            let earth = bodies.find(b => b.type === 'target_start');
            if (earth) {
                let { vec, power } = getLaunchVector();
                
                ctx.beginPath();
                ctx.moveTo(earth.pos.x, earth.pos.y);
                ctx.lineTo(mouse.x, mouse.y);
                ctx.strokeStyle = `rgba(255, ${255 * (1-power)}, ${255 * (1-power)}, 0.4)`;
                ctx.setLineDash([4, 4]);
                ctx.lineWidth = 1 * scaleFactor;
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.beginPath();
                ctx.moveTo(earth.pos.x, earth.pos.y);
                let simPos = earth.pos.copy();
                let dir = new Vector(mouse.x, mouse.y).sub(earth.pos);
                dir.normalize();
                simPos.add(dir.mult(earth.radius + (20 * scaleFactor))); 
                let simVel = vec.copy();
                
                // Prediction Scaling for Mobile gravity calc
                let localG = G_BASE * scaleFactor;

                for(let i=0; i<15; i++) {
                    let sun = bodies.find(b => b.type === 'sun');
                    if (!sun) break;
                    let f = sun.pos.sub(simPos);
                    let d = f.mag();
                    // Clamp prediction dist
                    let dClamped = Math.max(d, 10 * scaleFactor);
                    f.normalize();
                    let s = (localG * sun.mass * 1.5) / (dClamped * dClamped);
                    f.mult(s);
                    simVel.add(f);
                    simPos.add(simVel);
                    ctx.lineTo(simPos.x, simPos.y);
                }
                ctx.strokeStyle = 'rgba(0, 210, 255, 0.6)';
                ctx.lineWidth = 2 * scaleFactor;
                ctx.stroke();
            }
        }

        if (rocket) {
            rocket.update();
            rocket.draw();
            let centerDist = new Vector(rocket.pos.x - cx, rocket.pos.y - cy).mag();
            if (centerDist > Math.max(width, height) * 2) endGame(false, 'lost_space');
        }

        for(let i = particles.length -1; i>=0; i--) {
            particles[i].update();
            particles[i].draw();
            if(particles[i].life <= 0) particles.splice(i, 1);
        }

        ctx.restore();
        frameCount++;
        animationFrameId = requestAnimationFrame(loop);
    }

    function updateMouse(e) {
        // Handle touch and mouse unify
        let clientX, clientY;
        if (e.changedTouches && e.changedTouches.length > 0) {
            clientX = e.changedTouches[0].clientX;
            clientY = e.changedTouches[0].clientY;
        } else if (e.clientX !== undefined) {
            clientX = e.clientX;
            clientY = e.clientY;
        }
        
        if (clientX !== undefined) {
            mouse.x = clientX;
            mouse.y = clientY;
        }
    }

    function inputStart(e) {
        if (gameState === 'FLYING') {
            isThrusting = true;
            updateMouse(e);
        }
    }

    function inputEnd(e) {
        if (gameState === 'FLYING') {
            isThrusting = false;
        } else if (gameState === 'IDLE') {
            if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'SELECT' && !storeModal.contains(e.target)) {
                launch(e);
            }
        }
    }

    function launch(e) {
        let earth = bodies.find(b => b.type === 'target_start');
        const stats = getStats();

        updateMouse(e);
        let { vec } = getLaunchVector();

        // Rocket radius visually scaled: 4 * scaleFactor
        rocket = new Body(earth.pos.x, earth.pos.y, 1, 4, '#fff', false, 'rocket');
        rocket.vel = vec;
        rocket.fuel = stats.maxFuel;

        let dir = vec.copy();
        dir.normalize();
        let spawnOffset = dir.copy();
        spawnOffset.mult(earth.radius + (25 * scaleFactor));
        rocket.pos.add(spawnOffset);

        gameState = 'FLYING';
        statusText.innerText = "Hold Screen to Thrust!";
        statusText.style.color = "#ffaa00";
        fuelBarContainer.style.display = 'block';
    }

    window.addEventListener('mousemove', updateMouse);
    window.addEventListener('touchmove', (e) => { e.preventDefault(); updateMouse(e); }, {passive: false});
    window.addEventListener('mousedown', inputStart);
    window.addEventListener('touchstart', (e) => { e.preventDefault(); inputStart(e); }, {passive: false});
    window.addEventListener('mouseup', inputEnd);
    window.addEventListener('touchend', inputEnd);
    window.addEventListener('resize', resize);
    
    retryBtn.addEventListener('click', () => resetGame('stay'));
    nextLevelBtn.addEventListener('click', () => resetGame('next'));
    resetLevelBtn.addEventListener('click', () => resetGame('stay'));
    storeToggleBtn.addEventListener('click', (e) => { e.stopPropagation(); openStore(); });

    resize();
    createSolarSystem();
    loop();
})();
</script>
</body>
</html>