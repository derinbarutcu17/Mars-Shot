<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mars Shot: Orbital Injection</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            color: #fff;
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
            user-select: none;
        }
        #gameCanvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            pointer-events: none;
            z-index: 5;
            text-shadow: 1px 1px 2px black;
            width: 100%;
            box-sizing: border-box;
            padding-right: 40px;
        }
        /* Top Center Level Selector */
        #levelSelectContainer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            pointer-events: auto;
            z-index: 6;
        }
        #levelSelect {
            background-color: #9d00ff;
            color: white;
            border: 2px solid #fff;
            padding: 8px 15px;
            font-family: inherit;
            font-weight: bold;
            font-size: 16px;
            border-radius: 20px;
            cursor: pointer;
            outline: none;
            text-align: center;
        }
        #levelSelect:hover {
            background-color: #b84dff;
        }
        #levelSelect option {
            background-color: #222;
            color: #fff;
        }

        h1 {
            margin: 0;
            font-size: 24px;
            text-shadow: 0 0 10px #00d2ff;
        }
        p {
            margin: 5px 0;
            font-size: 14px;
            color: #ccc;
        }
        #fuelBarContainer {
            margin-top: 10px;
            width: 150px;
            height: 10px;
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid #fff;
            border-radius: 5px;
            overflow: hidden;
            display: none; 
        }
        #fuelBar {
            width: 100%;
            height: 100%;
            background: #ffaa00;
            transition: width 0.1s;
        }
        #coinText { color: #ffd700; font-weight: bold; }
        
        /* Message Modal */
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: none;
            display: none;
            z-index: 10;
            background: rgba(12, 12, 20, 0.95);
            padding: 30px;
            border: 2px solid #00d2ff;
            border-radius: 8px;
            min-width: 320px;
            box-shadow: 0 0 30px rgba(0, 210, 255, 0.2);
        }
        #message h2 {
            font-size: 32px;
            margin: 0 0 10px 0;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        .btn {
            pointer-events: auto;
            background: linear-gradient(180deg, #00d2ff 0%, #0078ff 100%);
            color: #fff;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            font-weight: bold;
            cursor: pointer;
            margin-top: 20px;
            border-radius: 4px;
            text-transform: uppercase;
            box-shadow: 0 4px 0 #0056b3;
            transition: transform 0.1s;
        }
        .btn:active { transform: translateY(4px); box-shadow: none; }
        .green-btn { background: linear-gradient(180deg, #44ff44 0%, #00aa00 100%); box-shadow: 0 4px 0 #006600; }
        
        /* Store Modal */
        #storeModal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(10, 10, 20, 0.98);
            border: 2px solid #ffd700;
            padding: 20px;
            border-radius: 10px;
            display: none;
            z-index: 20;
            width: 300px;
            text-align: center;
        }
        .upgrade-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 10px 0;
            border-bottom: 1px solid #333;
            padding-bottom: 10px;
        }
        .upgrade-info { text-align: left; }
        .upgrade-name { font-weight: bold; color: #fff; display: block;}
        .upgrade-cost { font-size: 12px; color: #ffd700; }
        .buy-btn {
            background: #333;
            color: #fff;
            border: 1px solid #555;
            padding: 5px 10px;
            cursor: pointer;
            font-size: 12px;
        }
        .buy-btn:hover { background: #444; }

        /* Replay Button */
        #resetLevelBtn {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(255, 50, 50, 0.2);
            border: 1px solid #ff4444;
            color: #ffaaaa;
            padding: 8px 15px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            pointer-events: auto;
            z-index: 5;
            transition: background 0.2s;
        }
        #resetLevelBtn:hover { background: rgba(255, 50, 50, 0.5); color: #fff; }

        #storeToggleBtn {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid #ffd700;
            color: #ffd700;
            padding: 8px 15px;
            cursor: pointer;
            font-family: inherit;
            font-weight: bold;
            pointer-events: auto;
            z-index: 5;
        }
        #storeToggleBtn:hover { background: rgba(255, 215, 0, 0.5); color: #fff; }

    </style>
</head>
<body>

<div id="levelSelectContainer">
    <select id="levelSelect" onchange="changeLevel(this.value)">
        <option value="1">Level 1</option>
        <option value="2">Level 2</option>
        <option value="3">Level 3</option>
        <option value="4">Level 4</option>
    </select>
</div>

<div id="ui">
    <h1>MARS SHOT</h1>
    <p>Coins: <span id="coinText">0</span></p>
    <p>Status: <span id="statusText">Waiting for launch...</span></p>
    <p>Closest: <span id="distanceText">--</span></p>
    <div id="fuelBarContainer">
        <div id="fuelBar"></div>
    </div>
</div>

<button id="resetLevelBtn">â†º RESET LEVEL</button>
<button id="storeToggleBtn">WORKSHOP</button>

<!-- Store Modal -->
<div id="storeModal">
    <h2 style="color:#ffd700; margin-top:0;">WORKSHOP</h2>
    <div id="upgradesList">
        <!-- Generated by JS -->
    </div>
    <button class="btn" onclick="closeStore()">Close</button>
</div>

<!-- End Game Modal -->
<div id="message">
    <h2 id="msgTitle">MISSION COMPLETE</h2>
    <p id="msgSub">Score: 100</p>
    <br>
    <button class="btn" id="retryBtn">Try Again</button>
    <button class="btn green-btn" id="nextLevelBtn" style="display:none; margin-left:10px;">Next Level</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
(function() {
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    
    // UI Elements
    const statusText = document.getElementById('statusText');
    const distanceText = document.getElementById('distanceText');
    const levelSelect = document.getElementById('levelSelect');
    const coinText = document.getElementById('coinText');
    const fuelBarContainer = document.getElementById('fuelBarContainer');
    const fuelBar = document.getElementById('fuelBar');
    const messageOverlay = document.getElementById('message');
    const msgTitle = document.getElementById('msgTitle');
    const msgSub = document.getElementById('msgSub');
    const retryBtn = document.getElementById('retryBtn');
    const nextLevelBtn = document.getElementById('nextLevelBtn');
    const resetLevelBtn = document.getElementById('resetLevelBtn');
    const storeModal = document.getElementById('storeModal');
    const storeToggleBtn = document.getElementById('storeToggleBtn');
    const upgradesList = document.getElementById('upgradesList');

    let width, height, cx, cy;
    let animationFrameId;

    // Game Constants
    const G = 0.35; // Lowered gravity
    const SUN_MASS = 5000;
    const EARTH_MASS = 100;
    const MARS_MASS = 80;
    const SATURN_MASS = 200;
    const MOON_MASS = 10;
    const MAX_INPUT_DIST = 400; 

    // Stats & Upgrades
    let coins = 0;
    let upgrades = {
        fuel: { level: 1, cost: 50, name: "Fuel Tank", max: 5 },
        thrust: { level: 1, cost: 80, name: "Ion Engine", max: 5 },
        launch: { level: 1, cost: 60, name: "Catapult", max: 5 }
    };

    function getStats() {
        return {
            maxFuel: 100 + (upgrades.fuel.level - 1) * 30,
            // Reduced thrust power by 50% (0.2 -> 0.1)
            thrustPower: 0.1 + (upgrades.thrust.level - 1) * 0.025,
            launchForceMin: 1.5,
            launchForceMax: 5.0 + (upgrades.launch.level - 1) * 1.0 
        };
    }

    // Game State
    let bodies = [];
    let rocket = null;
    let ghostTrail = [];
    let particles = [];
    let gameState = 'IDLE';
    let closestDist = Infinity;
    let level = 1;
    let stars = [];
    let shakeStrength = 0;
    let isThrusting = false;

    // Mouse tracking
    let mouse = { x: window.innerWidth / 2, y: window.innerHeight / 2 };

    class Vector {
        constructor(x, y) { this.x = x; this.y = y; }
        add(v) { if(v) { this.x += v.x; this.y += v.y; } }
        sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
        mult(n) { this.x *= n; this.y *= n; }
        mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
        normalize() { 
            let m = this.mag(); 
            if(m !== 0 && Number.isFinite(m)) { this.x /= m; this.y /= m; }
        }
        copy() { return new Vector(this.x, this.y); }
        heading() { return Math.atan2(this.y, this.x); }
    }

    class Body {
        constructor(x, y, mass, radius, color, isStatic = false, type = 'planet') {
            this.pos = new Vector(x, y);
            this.vel = new Vector(0, 0);
            this.acc = new Vector(0, 0);
            this.mass = mass;
            this.radius = radius;
            this.color = color;
            this.isStatic = isStatic;
            this.type = type;
            this.trail = [];
            
            // Orbit params (On-Rails)
            this.orbitCenter = null;
            this.parentBody = null; // For moons
            this.orbitRadius = 0;
            this.orbitAngle = Math.random() * Math.PI * 2;
            this.orbitSpeed = 0;

            // Oscillation params
            this.startPos = new Vector(x, y);
            this.oscillate = false;
            this.oscillateSpeed = 0.0;
            this.oscillateDist = 0;
            this.timeOffset = 0;

            // Rocket params
            this.fuel = 0;
            this.angle = 0;
            this.age = 0;

            // Asteroid Shape (Jagged)
            this.shapeVertices = [];
            if (this.type === 'obstacle') {
                let numPoints = 6 + Math.floor(Math.random() * 4); // 6 to 9 points
                for (let i = 0; i < numPoints; i++) {
                    let angle = (i / numPoints) * Math.PI * 2;
                    let r = this.radius * (0.7 + Math.random() * 0.6); // Random variation
                    this.shapeVertices.push({
                        x: Math.cos(angle) * r,
                        y: Math.sin(angle) * r
                    });
                }
            }
        }

        applyForce(f) {
            let fCopy = f.copy();
            fCopy.mult(1 / this.mass);
            this.acc.add(fCopy);
        }

        update() {
            // Planet On-Rails Logic
            if (this.orbitCenter) {
                this.orbitAngle += this.orbitSpeed;
                this.pos.x = this.orbitCenter.x + Math.cos(this.orbitAngle) * this.orbitRadius;
                this.pos.y = this.orbitCenter.y + Math.sin(this.orbitAngle) * this.orbitRadius;
                this.vel.x = -Math.sin(this.orbitAngle) * this.orbitRadius * this.orbitSpeed;
                this.vel.y = Math.cos(this.orbitAngle) * this.orbitRadius * this.orbitSpeed;
            } else if (this.parentBody) {
                // Moon/Ring Logic (Relative to parent)
                this.orbitAngle += this.orbitSpeed;
                this.pos.x = this.parentBody.pos.x + Math.cos(this.orbitAngle) * this.orbitRadius;
                this.pos.y = this.parentBody.pos.y + Math.sin(this.orbitAngle) * this.orbitRadius;
                this.vel.x = this.parentBody.vel.x - Math.sin(this.orbitAngle) * this.orbitRadius * this.orbitSpeed;
                this.vel.y = this.parentBody.vel.y + Math.cos(this.orbitAngle) * this.orbitRadius * this.orbitSpeed;
            } else if (!this.isStatic) {
                // Physics movement
                this.vel.add(this.acc);
                this.pos.add(this.vel);
            }
            
            this.acc.mult(0); 
            
            if (this.type === 'rocket') {
                this.age++;
                if (isThrusting) {
                    let target = new Vector(mouse.x, mouse.y);
                    let dir = target.sub(this.pos);
                    this.angle = dir.heading();
                } else if(this.vel.mag() > 0.1) {
                    this.angle = this.vel.heading();
                }
            }

            if (this.type === 'planet' || this.type === 'rocket') {
                if (frameCount % 5 === 0) {
                    this.trail.push({x: this.pos.x, y: this.pos.y});
                    let limit = this.type === 'rocket' ? 600 : 60;
                    if (this.trail.length > limit) this.trail.shift();
                }
            }
        }

        draw() {
            if (!Number.isFinite(this.pos.x) || !Number.isFinite(this.pos.y)) return;

            // Draw Dashed Orbit Line for Planets (Excluding tiny ring asteroids)
            if ((this.orbitCenter || (this.parentBody && this.type === 'moon')) && this.type !== 'obstacle') {
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 10]);
                
                if (this.orbitCenter) {
                    ctx.arc(this.orbitCenter.x, this.orbitCenter.y, this.orbitRadius, 0, Math.PI * 2);
                } else if (this.parentBody) {
                    ctx.arc(this.parentBody.pos.x, this.parentBody.pos.y, this.orbitRadius, 0, Math.PI * 2);
                }
                
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Trail
            if (this.trail.length > 1) {
                ctx.beginPath();
                ctx.strokeStyle = this.type === 'rocket' ? '#fff' : this.color;
                ctx.lineWidth = this.type === 'rocket' ? 1.5 : 1;
                ctx.globalAlpha = 0.3;
                for (let i = 0; i < this.trail.length - 1; i++) {
                    ctx.lineTo(this.trail[i].x, this.trail[i].y);
                }
                ctx.stroke();
                ctx.globalAlpha = 1.0;
            }

            // --- ROCKET DRAWING ---
            if (this.type === 'rocket') {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(this.angle);
                
                if (isThrusting && this.fuel > 0) {
                    ctx.beginPath();
                    ctx.moveTo(-10, -2);
                    ctx.lineTo(-20 - Math.random() * 8, 0);
                    ctx.lineTo(-10, 2);
                    ctx.fillStyle = '#ffaa00';
                    ctx.fill();
                }

                ctx.beginPath();
                ctx.ellipse(0, 0, 10, 4, 0, 0, Math.PI*2);
                ctx.fillStyle = '#eee';
                ctx.fill();
                ctx.beginPath();
                ctx.moveTo(-4, -4);
                ctx.lineTo(-12, -8);
                ctx.lineTo(-8, 0);
                ctx.lineTo(-12, 8);
                ctx.lineTo(-4, 4);
                ctx.fillStyle = '#cc3333';
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(3, 0, 3, 2, 0, 0, Math.PI*2);
                ctx.fillStyle = '#00d2ff';
                ctx.fill();
                
                ctx.restore();
                return;
            }

            // --- ASTEROID DRAWING ---
            if (this.type === 'obstacle' && this.shapeVertices.length > 0) {
                ctx.save();
                ctx.translate(this.pos.x, this.pos.y);
                ctx.rotate(this.orbitAngle * 2); // Slight self-rotation effect based on orbit
                ctx.beginPath();
                ctx.moveTo(this.shapeVertices[0].x, this.shapeVertices[0].y);
                for (let i = 1; i < this.shapeVertices.length; i++) {
                    ctx.lineTo(this.shapeVertices[i].x, this.shapeVertices[i].y);
                }
                ctx.closePath();
                ctx.fillStyle = this.color;
                ctx.fill();
                // Add texture detail
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.stroke();
                ctx.restore();
                return;
            }

            // --- PLANET DRAWING ---
            // Atmosphere/Glow
            if (this.type === 'sun' || this.type === 'target_start' || this.type === 'target_end' || this.type === 'saturn') {
                let glowSize = this.radius * 2;
                let g = ctx.createRadialGradient(this.pos.x, this.pos.y, this.radius, this.pos.x, this.pos.y, glowSize);
                g.addColorStop(0, this.color);
                g.addColorStop(1, 'rgba(0,0,0,0)');
                ctx.globalAlpha = 0.2;
                ctx.fillStyle = g;
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, glowSize, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }

            let grad = ctx.createRadialGradient(
                this.pos.x - this.radius*0.3, this.pos.y - this.radius*0.3, this.radius * 0.1,
                this.pos.x, this.pos.y, this.radius
            );

            if (this.type === 'sun') {
                grad.addColorStop(0, '#fff');
                grad.addColorStop(1, '#ff8800');
                ctx.shadowBlur = 40;
                ctx.shadowColor = '#ff8800';
            } else if (this.type === 'target_start') {
                grad.addColorStop(0, '#88ccff');
                grad.addColorStop(1, '#0055aa');
                ctx.shadowBlur = 0;
            } else if (this.type === 'target_end') {
                grad.addColorStop(0, '#ff8888');
                grad.addColorStop(1, '#aa2222');
                ctx.shadowBlur = 0;
            } else if (this.type === 'saturn') {
                grad.addColorStop(0, '#f4d03f');
                grad.addColorStop(1, '#b7950b');
                ctx.shadowBlur = 0;
            } else if (this.type === 'moon') {
                grad.addColorStop(0, '#ddd');
                grad.addColorStop(1, '#888');
                ctx.shadowBlur = 0;
            } else {
                grad.addColorStop(0, '#aaa');
                grad.addColorStop(1, '#555');
                ctx.shadowBlur = 0;
            }

            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
            ctx.fillStyle = grad;
            ctx.fill();
            ctx.shadowBlur = 0;
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.pos = new Vector(x, y);
            this.vel = new Vector((Math.random() - 0.5) * 4, (Math.random() - 0.5) * 4);
            this.life = 1.0;
            this.color = color;
            this.size = Math.random() * 3 + 1;
        }
        update() {
            this.pos.add(this.vel);
            this.life -= 0.03;
        }
        draw() {
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.size, 0, Math.PI*2);
            ctx.fill();
            ctx.globalAlpha = 1.0;
        }
    }

    function resize() {
        width = window.innerWidth;
        height = window.innerHeight;
        canvas.width = width;
        canvas.height = height;
        cx = width / 2;
        cy = height / 2;
        mouse.x = cx;
        mouse.y = cy;
        initStars();
        if (gameState === 'IDLE') resetGame('stay');
    }

    function initStars() {
        stars = [];
        for(let i=0; i<150; i++) {
            stars.push({
                x: Math.random() * width,
                y: Math.random() * height,
                size: Math.random() * 1.5,
                alpha: Math.random() * 0.8 + 0.2
            });
        }
    }

    function createSolarSystem() {
        bodies = [];
        
        // --- 1. THE SUN ---
        let sun = new Body(cx, cy, SUN_MASS, 30, '#ffd700', true, 'sun');
        bodies.push(sun);

        // --- 2. EARTH & MOON ---
        let r1 = Math.min(width, height) * 0.22;
        let earth = new Body(cx + r1, cy, EARTH_MASS, 10, '#4facfe', false, 'target_start');
        earth.orbitCenter = new Vector(cx, cy);
        earth.orbitRadius = r1;
        earth.orbitAngle = 0; // Earth starts at 0
        earth.orbitSpeed = 0.005; 
        bodies.push(earth);

        let moon = new Body(cx + r1 + 25, cy, MOON_MASS, 3, '#ccc', false, 'moon');
        moon.parentBody = earth;
        moon.orbitRadius = 25;
        moon.orbitSpeed = 0.08; 
        bodies.push(moon);

        // --- 3. MARS ---
        let r2 = Math.min(width, height) * 0.35;
        let startAngle = Math.PI; // ALWAYS OPPOSITE (180 degrees)
        
        let mars = new Body(cx, cy, MARS_MASS, 9, '#ff5e62', false, 'target_end');
        mars.orbitCenter = new Vector(cx, cy);
        mars.orbitRadius = r2;
        mars.orbitAngle = startAngle;
        mars.orbitSpeed = 0.003;
        bodies.push(mars);

        // --- 4. SATURN & RINGS (Level 4 feature, or distant background) ---
        // We add Saturn always but make it interactable
        let rSaturn = Math.min(width, height) * 0.48; 
        let saturn = new Body(cx, cy, SATURN_MASS, 18, '#f4d03f', false, 'saturn');
        saturn.orbitCenter = new Vector(cx, cy);
        saturn.orbitRadius = rSaturn;
        saturn.orbitAngle = Math.PI / 2;
        saturn.orbitSpeed = 0.001;
        bodies.push(saturn);

        // Saturn's Ring/Belt (Small deadly rocks)
        let ringCount = 12;
        for (let i = 0; i < ringCount; i++) {
            let ringRock = new Body(0, 0, 5, 2, '#8d6e63', false, 'obstacle'); // small rocks
            ringRock.parentBody = saturn;
            ringRock.orbitRadius = 30 + Math.random() * 10;
            ringRock.orbitAngle = (i / ringCount) * Math.PI * 2;
            ringRock.orbitSpeed = 0.05 + Math.random() * 0.02;
            bodies.push(ringRock);
        }

        // --- 5. ASTEROID OBSTACLES (Sun Orbiting) ---
        // Scaling difficulty based on Level
        // Level 1: 3 small, Level 2: 7 med, Level 3: 12 large, Level 4: 18 mixed
        
        let asteroidCount = 0;
        let minSize = 5;
        let maxSize = 10;
        let orbitZoneStart = r1 + 30; // Between Earth
        let orbitZoneEnd = r2 - 30;   // And Mars

        if (level === 1) {
            asteroidCount = 3;
            minSize = 6; maxSize = 10;
        } else if (level === 2) {
            asteroidCount = 8;
            minSize = 8; maxSize = 14;
        } else if (level === 3) {
            asteroidCount = 14;
            minSize = 10; maxSize = 18;
        } else if (level === 4) {
            asteroidCount = 20;
            minSize = 8; maxSize = 22;
            // Also put some between Mars and Saturn for Lvl 4 overshoot risk
            orbitZoneEnd = rSaturn - 30; 
        }

        for (let i = 0; i < asteroidCount; i++) {
            let size = minSize + Math.random() * (maxSize - minSize);
            let asteroid = new Body(0, 0, 20, size, '#777', false, 'obstacle');
            
            asteroid.orbitCenter = new Vector(cx, cy);
            // Random distance from sun within the zone
            asteroid.orbitRadius = orbitZoneStart + Math.random() * (orbitZoneEnd - orbitZoneStart);
            asteroid.orbitAngle = Math.random() * Math.PI * 2;
            // Random speed and direction
            let speed = 0.002 + Math.random() * 0.004;
            if (Math.random() > 0.5) speed *= -1; // some orbit clockwise
            asteroid.orbitSpeed = speed;
            
            bodies.push(asteroid);
        }
    }

    // Exposed to global scope for the select element
    window.changeLevel = function(val) {
        level = parseInt(val);
        resetGame('stay');
    }

    function resetGame(action) {
        if (action === 'reset') {
            level = 1;
            ghostTrail = [];
        } else if (action === 'next') {
            level++;
            ghostTrail = [];
            if (level > 4) level = 1;
        }
        
        // Sync Selector UI
        levelSelect.value = level;
        
        coinText.innerText = coins;
        
        gameState = 'IDLE';
        messageOverlay.style.display = 'none';
        nextLevelBtn.style.display = 'none';
        storeModal.style.display = 'none';
        
        rocket = null;
        closestDist = Infinity;
        distanceText.innerText = "--";
        fuelBarContainer.style.display = 'none';
        
        createSolarSystem();
        statusText.innerText = "Aim & Drag to Launch";
        statusText.style.color = "#fff";
    }

    function spawnExplosion(x, y, color) {
        shakeStrength = 10;
        for(let i=0; i<30; i++) {
            particles.push(new Particle(x, y, color));
        }
    }

    function calculateGravity() {
        if (!rocket) return;
        
        const stats = getStats();

        // Apply Manual Thrust
        if (isThrusting && rocket.fuel > 0) {
            let target = new Vector(mouse.x, mouse.y);
            let force = target.sub(rocket.pos); 
            force.normalize();
            force.mult(stats.thrustPower); 
            rocket.applyForce(force);
            rocket.fuel -= 0.5; 
            if(rocket.fuel < 0) rocket.fuel = 0;
            
            if (frameCount % 3 === 0) {
                    let exhaust = force.copy();
                    exhaust.mult(-5); 
                    particles.push(new Particle(rocket.pos.x, rocket.pos.y, '#ffaa00'));
            }
        }
        
        // Update Fuel UI
        let fuelPct = (rocket.fuel / stats.maxFuel) * 100;
        fuelBar.style.width = `${fuelPct}%`;

        // Apply Gravity from all bodies to Rocket
        for (let b of bodies) {
            if (b.type === 'rocket') continue; 
            
            let force = b.pos.sub(rocket.pos);
            let dist = force.mag();
            force.normalize();
            let strength = (G * b.mass * 1) / (dist * dist); 
            force.mult(strength);
            rocket.applyForce(force);

            // Collision (Reduced collision radius for smaller rocket: 3)
            // For irregular asteroids, we still use circular radius approx for simplicity/performance
            if (dist < b.radius + 3) { 
                // Store position before rocket might be nulled
                let rx = rocket.pos.x;
                let ry = rocket.pos.y;

                if (b.type === 'target_end') {
                    endGame(true, 'landed');
                } else if (b.type === 'target_start') {
                        if (rocket.age > 100) {
                            endGame(false, 'crashed');
                        } else {
                            // Still launching, ignore collision
                            continue; 
                        }
                } else {
                    endGame(false, 'crashed');
                }
                
                // If we get here, collision happened and game ended
                spawnExplosion(rx, ry, b.color);
                rocket = null; // Ensure null if not already
                return; 
            }
        }

        let mars = bodies.find(b => b.type === 'target_end');
        // Safety check for mars
        if (mars && rocket) {
             let d = rocket.pos.sub(mars.pos).mag();
             if (d < closestDist) {
                closestDist = d;
                distanceText.innerText = Math.floor(closestDist);
             }
        }
    }

    function endGame(success, reason) {
        gameState = 'ENDED';
        isThrusting = false;
        fuelBarContainer.style.display = 'none';
        
        // Set rocket to null to stop physics loop immediately (Fix infinite coins)
        let endRocketTrail = rocket ? [...rocket.trail] : [];
        rocket = null;
        if (endRocketTrail.length > 0) ghostTrail = endRocketTrail;

        if (success) {
            let earned = 100;
            coins += earned;
            msgTitle.innerText = "MARS LANDING!";
            msgTitle.style.color = "#44ff44";
            msgSub.innerText = `+${earned} Coins!`;
            retryBtn.innerText = "Replay Level";
            nextLevelBtn.style.display = "inline-block";
        } else {
            let distScore = Math.max(0, 50 - Math.floor(closestDist / 2));
            if (reason === 'crashed') distScore = 0;
            coins += distScore;

            if (reason === 'lost_space') {
                msgTitle.innerText = "LOST IN SPACE";
                msgTitle.style.color = "#ffaa00";
            } else {
                msgTitle.innerText = "CRASHED";
                msgTitle.style.color = "#ff4444";
            }
            msgSub.innerText = `Closest: ${Math.floor(closestDist)} | Earned: ${distScore} Coins`;
            retryBtn.innerText = "Try Again";
            nextLevelBtn.style.display = "none";
        }

        coinText.innerText = coins;
        messageOverlay.style.display = 'block';
    }

    function getLaunchVector() {
        let earth = bodies.find(b => b.type === 'target_start');
        if(!earth) return { vec: new Vector(0,0), power: 0 };
        
        const stats = getStats();

        let target = new Vector(mouse.x, mouse.y);
        let dir = target.sub(earth.pos);
        let dist = dir.mag();
        dir.normalize();

        let powerRatio = Math.min(dist, MAX_INPUT_DIST) / MAX_INPUT_DIST;
        let force = stats.launchForceMin + (stats.launchForceMax - stats.launchForceMin) * powerRatio;

        let launchVel = dir.copy();
        launchVel.mult(force);
        
        // Add Earth's orbital velocity
        if(earth.vel) launchVel.add(earth.vel);
        
        return { vec: launchVel, power: powerRatio };
    }

    // --- STORE LOGIC ---
    window.openStore = () => {
        storeModal.style.display = 'block';
        renderStore();
    };
    window.closeStore = () => {
        storeModal.style.display = 'none';
    };
    window.buyUpgrade = (type) => {
        let u = upgrades[type];
        if (u.level < u.max && coins >= u.cost) {
            coins -= u.cost;
            u.level++;
            u.cost = Math.floor(u.cost * 1.5);
            coinText.innerText = coins;
            renderStore();
        }
    };

    function renderStore() {
        upgradesList.innerHTML = '';
        for (let key in upgrades) {
            let u = upgrades[key];
            let row = document.createElement('div');
            row.className = 'upgrade-row';
            
            let btnText = u.level >= u.max ? "MAX" : `Buy (${u.cost}c)`;
            let disabled = (u.level >= u.max || coins < u.cost) ? "opacity:0.5; pointer-events:none;" : "";
            
            row.innerHTML = `
                <div class="upgrade-info">
                    <span class="upgrade-name">${u.name} (Lvl ${u.level})</span>
                </div>
                <button class="buy-btn" style="${disabled}" onclick="buyUpgrade('${key}')">${btnText}</button>
            `;
            upgradesList.appendChild(row);
        }
    }

    let frameCount = 0;
    function loop() {
        // Shake
        let shakeX = 0, shakeY = 0;
        if(shakeStrength > 0) {
            shakeX = (Math.random() - 0.5) * shakeStrength;
            shakeY = (Math.random() - 0.5) * shakeStrength;
            shakeStrength *= 0.9;
            if(shakeStrength < 0.5) shakeStrength = 0;
        }

        ctx.save();
        ctx.translate(shakeX, shakeY);
        ctx.fillStyle = '#050510';
        ctx.fillRect(-shakeX, -shakeY, width, height);

        // Stars
        for(let s of stars) {
            if(Math.random() < 0.01) s.alpha = Math.random() * 0.8 + 0.2;
            ctx.fillStyle = `rgba(255, 255, 255, ${s.alpha})`;
            ctx.beginPath();
            ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
            ctx.fill();
        }

        calculateGravity();

        for (let b of bodies) {
            b.update();
            b.draw();
        }

        // Ghost
        if (ghostTrail.length > 1) {
            ctx.beginPath();
            ctx.strokeStyle = '#00ffff'; 
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.2; 
            ctx.setLineDash([5, 5]);
            for (let i = 0; i < ghostTrail.length - 1; i++) {
                ctx.lineTo(ghostTrail[i].x, ghostTrail[i].y);
            }
            ctx.stroke();
            ctx.setLineDash([]);
            ctx.globalAlpha = 1.0;
        }

        if (gameState === 'IDLE') {
            let earth = bodies.find(b => b.type === 'target_start');
            if (earth) {
                let { vec, power } = getLaunchVector();
                
                ctx.beginPath();
                ctx.moveTo(earth.pos.x, earth.pos.y);
                ctx.lineTo(mouse.x, mouse.y);
                ctx.strokeStyle = `rgba(255, ${255 * (1-power)}, ${255 * (1-power)}, 0.4)`;
                ctx.setLineDash([4, 4]);
                ctx.lineWidth = 1;
                ctx.stroke();
                ctx.setLineDash([]);

                // Prediction (Simple gravity)
                ctx.beginPath();
                ctx.moveTo(earth.pos.x, earth.pos.y);
                let simPos = earth.pos.copy();
                let dir = new Vector(mouse.x, mouse.y).sub(earth.pos);
                dir.normalize();
                simPos.add(dir.mult(earth.radius + 15)); 
                let simVel = vec.copy();
                
                for(let i=0; i<15; i++) {
                    let sun = bodies.find(b => b.type === 'sun');
                    if (!sun) break;
                    let f = sun.pos.sub(simPos);
                    let d = f.mag();
                    f.normalize();
                    let s = (G * sun.mass * 1) / (d*d);
                    f.mult(s);
                    simVel.add(f);
                    simPos.add(simVel);
                    ctx.lineTo(simPos.x, simPos.y);
                }
                ctx.strokeStyle = 'rgba(0, 210, 255, 0.6)';
                ctx.lineWidth = 2;
                ctx.stroke();
            }
        }

        if (rocket) {
            rocket.update();
            rocket.draw();
            let centerDist = new Vector(rocket.pos.x - cx, rocket.pos.y - cy).mag();
            if (centerDist > Math.max(width, height) * 2) endGame(false, 'lost_space');
        }

        for(let i = particles.length -1; i>=0; i--) {
            particles[i].update();
            particles[i].draw();
            if(particles[i].life <= 0) particles.splice(i, 1);
        }

        ctx.restore();
        frameCount++;
        animationFrameId = requestAnimationFrame(loop);
    }

    function updateMouse(e) {
        if (e.type.includes('touch') && e.touches.length > 0) {
            mouse.x = e.touches[0].clientX;
            mouse.y = e.touches[0].clientY;
        } else if (e.clientX !== undefined) {
            mouse.x = e.clientX;
            mouse.y = e.clientY;
        }
    }

    function inputStart(e) {
        if (gameState === 'FLYING') {
            isThrusting = true;
            updateMouse(e);
        }
    }

    function inputEnd(e) {
        if (gameState === 'FLYING') {
            isThrusting = false;
        } else if (gameState === 'IDLE') {
            // Prevent launch if clicking dropdown
            if (e.target.tagName !== 'BUTTON' && e.target.tagName !== 'SELECT' && !storeModal.contains(e.target)) {
                launch(e);
            }
        }
    }

    function launch(e) {
        let earth = bodies.find(b => b.type === 'target_start');
        const stats = getStats();

        updateMouse(e);
        let { vec } = getLaunchVector();

        // Small rocket mass: 1, radius: 4 (visually matches draw)
        rocket = new Body(earth.pos.x, earth.pos.y, 1, 4, '#fff', false, 'rocket');
        rocket.vel = vec;
        rocket.fuel = stats.maxFuel;

        let dir = vec.copy();
        dir.normalize();
        let spawnOffset = dir.copy();
        // Safe spawn distance
        spawnOffset.mult(earth.radius + 20);
        rocket.pos.add(spawnOffset);

        gameState = 'FLYING';
        statusText.innerText = "Hold Click to Thrust!";
        statusText.style.color = "#ffaa00";
        fuelBarContainer.style.display = 'block';
    }

    window.addEventListener('mousemove', updateMouse);
    window.addEventListener('touchmove', updateMouse);
    window.addEventListener('mousedown', inputStart);
    window.addEventListener('touchstart', inputStart);
    window.addEventListener('mouseup', inputEnd);
    window.addEventListener('touchend', inputEnd);
    window.addEventListener('resize', resize);
    
    retryBtn.addEventListener('click', () => resetGame('stay'));
    nextLevelBtn.addEventListener('click', () => resetGame('next'));
    resetLevelBtn.addEventListener('click', () => resetGame('stay'));
    storeToggleBtn.addEventListener('click', (e) => { e.stopPropagation(); openStore(); });

    resize();
    createSolarSystem();
    loop();
})();
</script>
</body>
</html>